<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>特徴量マッチング</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <!-- <div style="display: flex; gap: 50px"> -->
    <video id="video" autoplay></video>
    <canvas
      id="canvas"
      width="640"
      height="480"
      style="position: absolute; top: 0; left: 0; display: none"
    >
    </canvas>
    <div
      style="
        position: absolute;
        top: 50px;
        left: 200px;
        width: 200px;
        height: 360px;
        border: 1px solid red;
        display: none;
      "
    >
      <p id="status">Loading OpenCV...</p>
      <p id="width">Loading OpenCV...</p>
      <p id="height">Loading OpenCV...</p>
    </div>

    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");
      let statusText = document.getElementById("status");
      let widthText = document.getElementById("width");
      let heightText = document.getElementById("height");
      let interval;

      function loadOpenCv() {
        console.log("Loading OpenCV.js...");
        let script = document.createElement("script");
        console.log("script");
        script.src = "https://docs.opencv.org/4.10.0/opencv.js";
        console.log("script.src");
        script.onload = onOpenCvReady;
        console.log("script.onload");
        script.onerror = onOpenCvError;
        console.log("script.onerror");
        document.body.appendChild(script);
        console.log("document.body.appendChild(script)");
      }

      function onOpenCvReady() {
        console.log("OpenCV.js script loaded.");
        statusText.textContent = "OpenCV.js script loaded, initializing...";
        checkOpenCvReady();
      }

      function onOpenCvError() {
        console.error("Failed to load OpenCV.js!");
        statusText.textContent = "Failed to load OpenCV.js!";
      }

      function checkOpenCvReady() {
        if (typeof cv !== "undefined" && cv.getBuildInformation) {
          console.log("OpenCV.js is ready.");
          statusText.textContent = "OpenCV.js is ready.";
          startProcessing();
        } else {
          console.log("OpenCV.js is not ready.");
          setTimeout(checkOpenCvReady, 100);
        }
      }

      function startProcessing() {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          video.srcObject = stream;
        });

        interval = setInterval(processImage, 1000);
      }

      function processImage() {
        if (typeof cv === "undefined" || !cv.imread) {
          console.log("OpenCV is not fully initialized yet.");
          return;
        }

        let statusText = document.getElementById("status");

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let src = cv.imread(canvas);

        // 画像のサイズ取得
        let width = src.cols;
        let height = src.rows;
        widthText.textContent = "width: " + width;
        heightText.textContent = "height: " + height;

        // 横の幅を高さの 1/2 にする
        let cropWidth = Math.floor(height * 0.4);
        let cropHeight = height * 0.8; // 縦はフルサイズ

        // 中央位置を計算
        let centerX = Math.floor(width / 2);

        // 切り取り範囲の指定
        let rect = new cv.Rect(
          centerX - Math.floor(cropWidth / 2), // X座標 (横中央)
          0, // Y座標 (上端からスタート)
          cropWidth, // 切り取る幅
          cropHeight // 切り取る高さ
        );

        let cropped = src.roi(rect); // 指定範囲を切り取る

        // 前処理（グレースケール & コントラスト強調）
        cv.cvtColor(cropped, cropped, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(cropped, cropped, new cv.Size(3, 3), 0);
        cv.equalizeHist(cropped, cropped);

        let orb = new cv.ORB();
        let keypoints = new cv.KeyPointVector();
        let descriptors = new cv.Mat();
        orb.detectAndCompute(cropped, new cv.Mat(), keypoints, descriptors);

        fetch("features.json")
          .then((response) => response.json())
          .then((savedFeatures) => {
            let savedDescriptors = new cv.Mat();
            let descriptorArray = savedFeatures.descriptors.flat();

            if (descriptorArray.length % 32 !== 0) {
              console.error("データサイズが不正です: ", descriptorArray.length);
              return;
            }

            let descriptorUint8Array = new Uint8Array(descriptorArray);
            savedDescriptors.create(descriptorArray.length / 32, 32, cv.CV_8U);
            savedDescriptors.data.set(descriptorUint8Array);

            if (descriptors.empty()) {
              console.log("No descriptors found.");
              statusText.textContent = "良いマッチ数: 0";
              return;
            }

            let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
            let matches = new cv.DMatchVectorVector();
            bf.knnMatch(descriptors, savedDescriptors, matches, 2);

            let goodMatches = 0;
            for (let i = 0; i < matches.size(); i++) {
              let m = matches.get(i).get(0);
              let n = matches.get(i).get(1);
              if (m.distance < 0.8 * n.distance) {
                goodMatches++;
              }
            }

            console.log("良いマッチ数:", goodMatches);
            statusText.textContent = "良いマッチ数: " + goodMatches;

            // ページ遷移をコメントアウト
            if (goodMatches > 11) {
              model.visible = true;
              //  setInterval(processImage, 1000)を止める。
              clearInterval(interval);
            }

            src.delete();
            cropped.delete();
            descriptors.delete();
            keypoints.delete();
            matches.delete();
            savedDescriptors.delete();
          });
      }

      async function startCamera() {
        let constraints = {
          video: {
            facingMode: "environment", // 外カメラを優先
            width: { ideal: 1280 }, // 解像度を調整（1280x720 以上を推奨）
            height: { ideal: 720 },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("カメラの起動に失敗しました:", error);
          selectCameraManually(); // 手動でカメラを選択
        }
      }

      // カメラ一覧を取得し、外カメラを探す
      async function selectCameraManually() {
        let devices = await navigator.mediaDevices.enumerateDevices();
        let videoDevices = devices.filter(
          (device) => device.kind === "videoinput"
        );

        if (videoDevices.length === 0) {
          console.error("カメラデバイスが見つかりません");
          return;
        }

        let backCamera = videoDevices.find((device) =>
          device.label.toLowerCase().includes("back")
        );

        let constraints = {
          video: {
            deviceId: backCamera
              ? { exact: backCamera.deviceId }
              : { exact: videoDevices[0].deviceId },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("カメラの手動選択に失敗しました:", error);
        }
      }

      // ページ読み込み時に外カメラを起動
      window.onload = startCamera;

      // 📌 カメラ映像の取得
      navigator.mediaDevices
        .getUserMedia({ video: { facingMode: "environment" } })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((err) => {
          console.error("カメラのアクセスに失敗しました:", err);
        });

      // 📌 Three.js のシーンを作成
      const scene = new THREE.Scene();

      // 📌 カメラ設定
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 2); // 3Dオブジェクトを表示する位置

      // 📌 レンダラー設定（背景透明）
      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 📌 ライト設定
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // 環境光
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(10, 10, 10); // ライトの方向
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0xffffff, 2, 100);
      pointLight.position.set(0, 5, 5);
      scene.add(pointLight);

      // 🎯 モデルを直接照らす SpotLight（黄色の強めのライト）
      const spotLight = new THREE.SpotLight(0xffffff, 3, 300, Math.PI / 6, 0.5);
      spotLight.position.set(0, 10, 10);
      scene.add(spotLight);

      // 📌 3Dモデル（Pikachu.glb）をロード
      let model;
      const loader = new THREE.GLTFLoader();
      loader.load("pikachu.glb", function (gltf) {
        model = gltf.scene;
        model.scale.set(0.04, 0.04, 0.04); // サイズ調整
        model.position.set(0, -1, 0); // 位置調整
        model.visible = false;
        scene.add(model);
      });

      // 📌 アニメーションループ
      function animate() {
        requestAnimationFrame(animate);
        if (model) {
          model.rotation.y += 0.01; // モデルを回転
        }
        renderer.render(scene, camera);
      }
      animate();

      // 📌 ウィンドウリサイズ対応
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      window.onload = loadOpenCv; // OpenCV.js を動的にロード
    </script>
  </body>
</html>
