<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>特徴量マッチング</title>
  </head>
  <body>
    <div style="display: flex; gap: 50px">
      <div style="position: relative">
        <video id="video" autoplay></video>
        <div
          style="
            position: absolute;
            top: 50px;
            left: 200px;
            width: 200px;
            height: 360px;
            border: 1px solid red;
          "
        ></div>
      </div>
      <canvas id="canvas" width="640" height="480"> </canvas>
    </div>
    <p id="status">Loading OpenCV...</p>
    <p id="width">Loading OpenCV...</p>
    <p id="height">Loading OpenCV...</p>

    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");
      let statusText = document.getElementById("status");
      let widthText = document.getElementById("width");
      let heightText = document.getElementById("height");

      function loadOpenCv() {
        let script = document.createElement("script");
        script.src = "https://docs.opencv.org/4.10.0/opencv.js";
        script.onload = onOpenCvReady;
        script.onerror = onOpenCvError;
        document.body.appendChild(script);
      }

      function onOpenCvReady() {
        console.log("OpenCV.js script loaded.");
        statusText.textContent = "OpenCV.js script loaded, initializing...";
        checkOpenCvReady();
      }

      function onOpenCvError() {
        console.error("Failed to load OpenCV.js!");
        statusText.textContent = "Failed to load OpenCV.js!";
      }

      function checkOpenCvReady() {
        if (typeof cv !== "undefined" && cv.getBuildInformation) {
          console.log("OpenCV.js is ready.");
          statusText.textContent = "OpenCV.js is ready.";
          startProcessing();
        } else {
          setTimeout(checkOpenCvReady, 100);
        }
      }

      function startProcessing() {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          video.srcObject = stream;
        });

        setInterval(processImage, 1000);
      }

      function processImage() {
        if (typeof cv === "undefined" || !cv.imread) {
          console.log("OpenCV is not fully initialized yet.");
          return;
        }

        let statusText = document.getElementById("status");

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let src = cv.imread(canvas);

        // 画像のサイズ取得
        let width = src.cols;
        let height = src.rows;
        widthText.textContent = "width: " + width;
        heightText.textContent = "height: " + height;

        // 横の幅を高さの 1/2 にする
        let cropWidth = Math.floor(height * 0.4);
        let cropHeight = height * 0.8; // 縦はフルサイズ

        // 中央位置を計算
        let centerX = Math.floor(width / 2);

        // 切り取り範囲の指定
        let rect = new cv.Rect(
          centerX - Math.floor(cropWidth / 2), // X座標 (横中央)
          0, // Y座標 (上端からスタート)
          cropWidth, // 切り取る幅
          cropHeight // 切り取る高さ
        );

        let cropped = src.roi(rect); // 指定範囲を切り取る

        // 前処理（グレースケール & コントラスト強調）
        cv.cvtColor(cropped, cropped, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(cropped, cropped, new cv.Size(3, 3), 0);
        cv.equalizeHist(cropped, cropped);

        let orb = new cv.ORB();
        let keypoints = new cv.KeyPointVector();
        let descriptors = new cv.Mat();
        orb.detectAndCompute(cropped, new cv.Mat(), keypoints, descriptors);

        fetch("features.json")
          .then((response) => response.json())
          .then((savedFeatures) => {
            let savedDescriptors = new cv.Mat();
            let descriptorArray = savedFeatures.descriptors.flat();

            if (descriptorArray.length % 32 !== 0) {
              console.error("データサイズが不正です: ", descriptorArray.length);
              return;
            }

            let descriptorUint8Array = new Uint8Array(descriptorArray);
            savedDescriptors.create(descriptorArray.length / 32, 32, cv.CV_8U);
            savedDescriptors.data.set(descriptorUint8Array);

            if (descriptors.empty()) {
              console.log("No descriptors found.");
              statusText.textContent = "良いマッチ数: 0";
              return;
            }

            let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
            let matches = new cv.DMatchVectorVector();
            bf.knnMatch(descriptors, savedDescriptors, matches, 2);

            let goodMatches = 0;
            for (let i = 0; i < matches.size(); i++) {
              let m = matches.get(i).get(0);
              let n = matches.get(i).get(1);
              if (m.distance < 0.8 * n.distance) {
                goodMatches++;
              }
            }

            console.log("良いマッチ数:", goodMatches);
            statusText.textContent = "良いマッチ数: " + goodMatches;

            // ページ遷移をコメントアウト
            if (goodMatches > 11) {
              window.location.href = "https://avalon-45913.web.app";
            }

            src.delete();
            cropped.delete();
            descriptors.delete();
            keypoints.delete();
            matches.delete();
            savedDescriptors.delete();
          });
      }

      window.onload = loadOpenCv; // OpenCV.js を動的にロード

      async function startCamera() {
        let constraints = {
          video: {
            facingMode: "environment", // 外カメラを優先
            width: { ideal: 1280 }, // 解像度を調整（1280x720 以上を推奨）
            height: { ideal: 720 },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("カメラの起動に失敗しました:", error);
          selectCameraManually(); // 手動でカメラを選択
        }
      }

      // カメラ一覧を取得し、外カメラを探す
      async function selectCameraManually() {
        let devices = await navigator.mediaDevices.enumerateDevices();
        let videoDevices = devices.filter(
          (device) => device.kind === "videoinput"
        );

        if (videoDevices.length === 0) {
          console.error("カメラデバイスが見つかりません");
          return;
        }

        let backCamera = videoDevices.find((device) =>
          device.label.toLowerCase().includes("back")
        );

        let constraints = {
          video: {
            deviceId: backCamera
              ? { exact: backCamera.deviceId }
              : { exact: videoDevices[0].deviceId },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("カメラの手動選択に失敗しました:", error);
        }
      }

      // ページ読み込み時に外カメラを起動
      window.onload = startCamera;
    </script>
  </body>
</html>
