<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ÁâπÂæ¥Èáè„Éû„ÉÉ„ÉÅ„É≥„Ç∞</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: -1;
      }
    </style>
  </head>
  <body>
    <!-- <div style="display: flex; gap: 50px"> -->
    <video id="video"></video>
    <canvas
      id="canvas"
      width="640"
      height="480"
      style="position: absolute; top: 0; left: 0; display: none"
    >
    </canvas>
    <div
      style="
        position: absolute;
        top: 50px;
        left: 200px;
        width: 200px;
        height: 360px;
        border: 1px solid red;
        display: none;
      "
    >
      <p id="status">Loading OpenCV...</p>
      <p id="width">Loading OpenCV...</p>
      <p id="height">Loading OpenCV...</p>
    </div>
    <button id="startCamera">„Ç´„É°„É©„ÇíÈñãÂßã</button>

    <script>
      let video = document.getElementById("video");
      let canvas = document.getElementById("canvas");
      let ctx = canvas.getContext("2d");
      let statusText = document.getElementById("status");
      let widthText = document.getElementById("width");
      let heightText = document.getElementById("height");
      let interval;

      function loadOpenCv() {
        console.log("Loading OpenCV.js...");
        let script = document.createElement("script");
        console.log("script");
        script.src = "https://docs.opencv.org/4.10.0/opencv.js";
        console.log("script.src");
        script.onload = onOpenCvReady;
        console.log("script.onload");
        script.onerror = onOpenCvError;
        console.log("script.onerror");
        document.body.appendChild(script);
        console.log("document.body.appendChild(script)");
      }

      function onOpenCvReady() {
        console.log("OpenCV.js script loaded.");
        statusText.textContent = "OpenCV.js script loaded, initializing...";
        checkOpenCvReady();
      }

      function onOpenCvError() {
        console.error("Failed to load OpenCV.js!");
        statusText.textContent = "Failed to load OpenCV.js!";
      }

      function checkOpenCvReady() {
        if (typeof cv !== "undefined" && cv.getBuildInformation) {
          console.log("OpenCV.js is ready.");
          statusText.textContent = "OpenCV.js is ready.";
          startProcessing();
        } else {
          console.log("OpenCV.js is not ready.");
          setTimeout(checkOpenCvReady, 100);
        }
      }

      function startProcessing() {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
          video.srcObject = stream;
          video.play();
        });

        interval = setInterval(processImage, 1000);
      }

      function processImage() {
        if (typeof cv === "undefined" || !cv.imread) {
          console.log("OpenCV is not fully initialized yet.");
          return;
        }

        let statusText = document.getElementById("status");

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let src = cv.imread(canvas);

        // ÁîªÂÉè„ÅÆ„Çµ„Ç§„Ç∫ÂèñÂæó
        let width = src.cols;
        let height = src.rows;
        widthText.textContent = "width: " + width;
        heightText.textContent = "height: " + height;

        // Ê®™„ÅÆÂπÖ„ÇíÈ´ò„Åï„ÅÆ 1/2 „Å´„Åô„Çã
        let cropWidth = Math.floor(height * 0.4);
        let cropHeight = height * 0.8; // Á∏¶„ÅØ„Éï„É´„Çµ„Ç§„Ç∫

        // ‰∏≠Â§Æ‰ΩçÁΩÆ„ÇíË®àÁÆó
        let centerX = Math.floor(width / 2);

        // Âàá„ÇäÂèñ„ÇäÁØÑÂõ≤„ÅÆÊåáÂÆö
        let rect = new cv.Rect(
          centerX - Math.floor(cropWidth / 2), // XÂ∫ßÊ®ô (Ê®™‰∏≠Â§Æ)
          0, // YÂ∫ßÊ®ô (‰∏äÁ´Ø„Åã„Çâ„Çπ„Çø„Éº„Éà)
          cropWidth, // Âàá„ÇäÂèñ„ÇãÂπÖ
          cropHeight // Âàá„ÇäÂèñ„ÇãÈ´ò„Åï
        );

        let cropped = src.roi(rect); // ÊåáÂÆöÁØÑÂõ≤„ÇíÂàá„ÇäÂèñ„Çã

        // ÂâçÂá¶ÁêÜÔºà„Ç∞„É¨„Éº„Çπ„Ç±„Éº„É´ & „Ç≥„É≥„Éà„É©„Çπ„ÉàÂº∑Ë™øÔºâ
        cv.cvtColor(cropped, cropped, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(cropped, cropped, new cv.Size(3, 3), 0);
        cv.equalizeHist(cropped, cropped);

        let orb = new cv.ORB();
        let keypoints = new cv.KeyPointVector();
        let descriptors = new cv.Mat();
        orb.detectAndCompute(cropped, new cv.Mat(), keypoints, descriptors);

        fetch("features.json")
          .then((response) => response.json())
          .then((savedFeatures) => {
            let savedDescriptors = new cv.Mat();
            let descriptorArray = savedFeatures.descriptors.flat();

            if (descriptorArray.length % 32 !== 0) {
              console.error("„Éá„Éº„Çø„Çµ„Ç§„Ç∫„Åå‰∏çÊ≠£„Åß„Åô: ", descriptorArray.length);
              return;
            }

            let descriptorUint8Array = new Uint8Array(descriptorArray);
            savedDescriptors.create(descriptorArray.length / 32, 32, cv.CV_8U);
            savedDescriptors.data.set(descriptorUint8Array);

            if (descriptors.empty()) {
              console.log("No descriptors found.");
              statusText.textContent = "ËâØ„ÅÑ„Éû„ÉÉ„ÉÅÊï∞: 0";
              return;
            }

            let bf = new cv.BFMatcher(cv.NORM_HAMMING, false);
            let matches = new cv.DMatchVectorVector();
            bf.knnMatch(descriptors, savedDescriptors, matches, 2);

            let goodMatches = 0;
            for (let i = 0; i < matches.size(); i++) {
              let m = matches.get(i).get(0);
              let n = matches.get(i).get(1);
              if (m.distance < 0.8 * n.distance) {
                goodMatches++;
              }
            }

            console.log("ËâØ„ÅÑ„Éû„ÉÉ„ÉÅÊï∞:", goodMatches);
            statusText.textContent = "ËâØ„ÅÑ„Éû„ÉÉ„ÉÅÊï∞: " + goodMatches;

            // „Éö„Éº„Ç∏ÈÅ∑Áßª„Çí„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà
            if (goodMatches > 11) {
              model.visible = true;
              //  setInterval(processImage, 1000)„ÇíÊ≠¢„ÇÅ„Çã„ÄÇ
              clearInterval(interval);
            }

            src.delete();
            cropped.delete();
            descriptors.delete();
            keypoints.delete();
            matches.delete();
            savedDescriptors.delete();
          });
      }

      async function startCamera() {
        let constraints = {
          video: {
            facingMode: "environment", // Â§ñ„Ç´„É°„É©„ÇíÂÑ™ÂÖà
            width: { ideal: 1280 }, // Ëß£ÂÉèÂ∫¶„ÇíË™øÊï¥Ôºà1280x720 ‰ª•‰∏ä„ÇíÊé®Â•®Ôºâ
            height: { ideal: 720 },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("„Ç´„É°„É©„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
          selectCameraManually(); // ÊâãÂãï„Åß„Ç´„É°„É©„ÇíÈÅ∏Êäû
        }
      }

      // „Ç´„É°„É©‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„ÄÅÂ§ñ„Ç´„É°„É©„ÇíÊé¢„Åô
      async function selectCameraManually() {
        let devices = await navigator.mediaDevices.enumerateDevices();
        let videoDevices = devices.filter(
          (device) => device.kind === "videoinput"
        );

        if (videoDevices.length === 0) {
          console.error("„Ç´„É°„É©„Éá„Éê„Ç§„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì");
          return;
        }

        let backCamera = videoDevices.find((device) =>
          device.label.toLowerCase().includes("back")
        );

        let constraints = {
          video: {
            deviceId: backCamera
              ? { exact: backCamera.deviceId }
              : { exact: videoDevices[0].deviceId },
          },
        };

        try {
          let stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
        } catch (error) {
          console.error("„Ç´„É°„É©„ÅÆÊâãÂãïÈÅ∏Êäû„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
        }
      }

      // üìå „Ç´„É°„É©Êò†ÂÉè„ÅÆÂèñÂæó
      navigator.mediaDevices
        .getUserMedia({ video: { facingMode: "environment" } })
        .then((stream) => {
          video.srcObject = stream;
        })
        .catch((err) => {
          console.error("„Ç´„É°„É©„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", err);
        });

      // üìå Three.js „ÅÆ„Ç∑„Éº„É≥„Çí‰ΩúÊàê
      const scene = new THREE.Scene();

      // üìå „Ç´„É°„É©Ë®≠ÂÆö
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 2); // 3D„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíË°®Á§∫„Åô„Çã‰ΩçÁΩÆ

      // üìå „É¨„É≥„ÉÄ„É©„ÉºË®≠ÂÆöÔºàËÉåÊôØÈÄèÊòéÔºâ
      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // üìå „É©„Ç§„ÉàË®≠ÂÆö
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); // Áí∞Â¢ÉÂÖâ
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(10, 10, 10); // „É©„Ç§„Éà„ÅÆÊñπÂêë
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0xffffff, 2, 100);
      pointLight.position.set(0, 5, 5);
      scene.add(pointLight);

      // üéØ „É¢„Éá„É´„ÇíÁõ¥Êé•ÁÖß„Çâ„Åô SpotLightÔºàÈªÑËâ≤„ÅÆÂº∑„ÇÅ„ÅÆ„É©„Ç§„ÉàÔºâ
      const spotLight = new THREE.SpotLight(0xffffff, 3, 300, Math.PI / 6, 0.5);
      spotLight.position.set(0, 10, 10);
      scene.add(spotLight);

      // üìå 3D„É¢„Éá„É´ÔºàPikachu.glbÔºâ„Çí„É≠„Éº„Éâ
      let model;
      const loader = new THREE.GLTFLoader();
      loader.load("pikachu.glb", function (gltf) {
        model = gltf.scene;
        model.scale.set(0.04, 0.04, 0.04); // „Çµ„Ç§„Ç∫Ë™øÊï¥
        model.position.set(0, -1, 0); // ‰ΩçÁΩÆË™øÊï¥
        model.visible = false;
        scene.add(model);
      });

      // üìå „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
      function animate() {
        requestAnimationFrame(animate);
        if (model) {
          model.rotation.y += 0.01; // „É¢„Éá„É´„ÇíÂõûËª¢
        }
        renderer.render(scene, camera);
      }
      animate();

      // üìå „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÂØæÂøú
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      //   window.onload = loadOpenCv; // OpenCV.js „ÇíÂãïÁöÑ„Å´„É≠„Éº„Éâ

      // „Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Å®„Åç„Å´„Ç´„É°„É©„ÇíÈñãÂßã
      document.getElementById("startCamera").addEventListener("click", () => {
        startCamera();
        loadOpenCv();
      });
    </script>
  </body>
</html>
